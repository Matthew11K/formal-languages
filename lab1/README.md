# Лабораторная работа №1

## Исходная система переписываний

```text
caa -> ac  (1)
acb -> adb  (2)
ad  -> daaa  (3)
bd  -> bc  (4)
```

## 1. Завершимость

Рассматриваем исходную SRS над алфавитом \(\Sigma=\{a,b,c,d\}\)


### 1). Разбиение на блоки по `b`
Любое слово \(w\) единственным образом раскладывается на фрагменты:
- префикс \(P\) до первого `b` (возможно пустой, не содержит `b`);
- последовательность блоков \(B_i = b\,U_i\) между соседними `b` (внутри \(U_i\) нет `b`);
- суффикс \(S\) после последнего `b` (возможно пустой, не содержит `b`).

Ни одно правило не удаляет/не вставляет `b` и не перепрыгивает через `b`, поэтому:
- число и порядок блоков фиксированы;
- каждый блок переписывается независимо.


Достаточно доказать, что в каждом блоке число шагов конечно. Варианты окружения:
1) в начале слова нет `b` (работаем в \(P\));
2) в конце нет `b` (работаем в \(S\));
3) стандартный блок между двумя `b` (работаем в \(B\));
4) если в слове нет `b` вовсе — это частный случай (только \(P=S=w\)).

### 2). Правило \((4)\) `bd → bc` применяется в блоке конечное число раз

Рассмотрим один блок \(B = b\,U\).

**Первое возможное применение.** Если блок начинается с `bd`:
\[
\underline{b\,d}\,\ldots \;\xRightarrow{(4)}\; \underline{b\,c}\,\ldots
\]

После этого попробуем понять, может ли снова появиться `bd` в начале этого же блока. Исчерпывающие варианты:

- **Если сразу после `bc` идут две `a`,** то применимо только \((1)\) к подстроке `caa`:
\[
b\,\underline{caa}\,\ldots \;\xRightarrow{(1)}\; b\,\underline{ac}\,\ldots \;=\; b\,a\,c\,\ldots
\]
получили префикс блока вида `bac…`.

- **Если далее образуется `bacb`,** то срабатывает связка:
\[
b\,a\,\underline{c\,b}\;\xRightarrow{(2)}\; b\,a\,\underline{d\,b}
\;\xRightarrow{(3)}\; b\,\underline{d}\,a^3 b
\;\xRightarrow{(4)}\; b\,\underline{c}\,a^3 b
\;\xRightarrow{(1)}\; b\,a\,c\,a\,b \;=\; \texttt{bacab}.
\]
Дальше в этом блоке правил больше нет (в частности, префикс `bd` в блоке не возникает повторно).

Итого: в одном блоке правило \((4)\) может сработать только конечное число раз (фактически - не более одного раза у левой границы блока). Следовательно, во всём слове \((4)\) применяется конечное число раз (сумма по конечному числу блоков).

---

### 3). Правило \((2)\) `acb → adb` тоже применяется конечное число раз

Берём любое вхождение `acb` внутри блока \(B\):
\[
\ldots\,\underline{a\,c\,b}\;\xRightarrow{(2)}\;\ldots\,\underline{a\,d\,b}.
\]

Дальнейшие пути переписывания из \(\ldots\,adb\) конечны. Разберём два сценария:

**(A) Ближайший слева к `d` символ — `a`.** Тогда цепочка \((3)\) двигает этот конкретный `d` влево через конечное число `a`:
\[
\ldots\,a^{m}\,d\,b \;\xRightarrow{(3)\times m}\; \ldots\,d\,a^{3m}\,b.
\]
Если слева от получившегося `d` стоит `b` (то есть мы находимся у начала блока), то один раз срабатывает \((4)\):
\[
b\,d\,a^{3m}b \;\xRightarrow{(4)}\; b\,c\,a^{3m}b.
\]

После \( (3)\times m \) и одного \( (4) \) получаем хвост с \(t:=3m\):
\[
\ldots\,a^m d b \;\xRightarrow{(3)\times m}\; \ldots\, b\,d\,a^{3m}b
\;\xRightarrow{(4)}\; \ldots\, b\,c\,a^{3m}b.
\]

Дальше рассматриваем два случая для \(t=3m\):

- **Если \(t\) нечётно**, то применяем \( (1)\;caa\to ac \) к последнему `c` ровно \(\lfloor t/2\rfloor\) раз и убываем
  \[
  b\,c\,a^{t}b \;\xRightarrow{(1)^{\lfloor t/2\rfloor}}\; b\,a^{\frac{t-1}{2}}\,c\,a\,b,
  \]
  после чего правил в блоке больше нет.

- **Если \(t\) чётно**, напишем \(t=2n\). Тогда выполняется один конечный четный цикл:
  \[
  b\,c\,a^{2n}b \xRightarrow{(1)\times n} b\,a^{n}c\,b
  \xRightarrow{(2)} b\,a^{n}d\,b
  \xRightarrow{(3)\times n} b\,d\,a^{3n}b
  \xRightarrow{(4)} b\,c\,a^{3n}b.
  \]
  После цикла новый хвост снова имеет вид \(c\,a^{3n}b\).
 Если \(3n\) нечётно, то после цикла имеем \(b\,c\,a^{3n}b\); далее по \( (1) \) делаем \(\frac{3n-1}{2}\) шагов и получаем
\[
b\,c\,a^{3n}b \;\xRightarrow{(1)^{\frac{3n-1}{2}}}\; b\,a^{\frac{3n-1}{2}}\,c\,a\,b,
\]
после чего в блоке правил больше нет.
  Если \(3n\) чётно, то \(n\) было чётным: положим \(n=2n_1\). Тогда
  \(3n = 6n_1 = 2\cdot(3n_1)\), то есть для следующего цикла берём \(2n'=3n\) с
  \(n' = \tfrac{3n}{2} = 3n_1\). При этом одна двойка из разложения (t\) по основанию 2 исчезает.  
  Повторяя, мы каждый раз устраняем по одной такой двойке; их конечное число, значит число циклов конечно. На последнем шаге \(t\) станет нечётным и дальше убывает по \( (1) \) до \(1\).


**(B) Если слева от `adb` есть фрагменты вида `…caa…`,** то \((1)\) применяется только к этим подстрокам левее `d` и не влияет на правый хвост блока; таких применений конечное число (каждый раз съедается одна пара `aa` около соответствующего `c`). После указанных применений правила \( (1) \) сочетание `acb` в этом блоке больше не образуется (последний перед `b` символ остаётся `d`).

 В обоих сценариях после одного применения \( (2) \) дальнейшие переписывания в блоке конечны, и повторное образование `acb` в этом блоке не происходит. Следовательно, в каждом блоке правило \( (2) \) может сработать только конечное число раз (и суммарно по слову — тоже конечно).

---

### 4). Поведение \((3)\) и убывающая мера (для исключения долгих цепочек)

Правило \((3)\) локально меняет только пару `a d` → `d a a a`, двигая конкретный символ `d` ровно на одну позицию влево. Это действие нельзя повторять бесконечно для одного и того же `d`, потому что число `a` слева от него конечно.

Формализуем это общей мерой, убывающей на бесконечных участках:


Нумеруем текущие символы `d` слева направо: \(d_1,\dots,d_k\).
Пусть \(g(d_i)\) — число букв `a` **слева** от \(d_i\),
а \(A(w)\) — общее число букв `a` в слове.
Определим лексикографическую меру
\[
\mathbf{M}(w) \;=\; \big(g(d_1),\dots,g(d_k),\,A(w)\big).
\]

Её поведение под правилами:

- \( (3)\;ad\to daaa \): двигает конкретный `d` на одну позицию влево ⇒ соответствующий \(g(d_i)\) уменьшается на 1 ⇒ \(\mathbf{M}\) строго убывает.

- \( (1)\;caa\to ac \): всегда уменьшает \(A(w)\) на 1.  
  Дополнительно, если правее места переписывания существует хотя бы один `d`, то для первого такого \(d_j\) величина \(g(d_j)\) также уменьшается на 1
  (все координаты \(g(d_i)\) с \(i<j\) не меняются).  
  В обоих случаях \(\mathbf{M}\) лексикографически убывает.

- \( (2)\;acb\to adb \) и \( (4)\;bd\to bc \): по пунктам 2)–3) доказательства каждое из этих правил в любом блоке применяется лишь конечное число раз, так что их вклад в общую конечность ограничен.

Следовательно, на любых потенциально длинных участках, где могут повторяться только \( (1) \) и/или \( (3) \), мера \(\mathbf{M}\) строго убывает и не может убывать бесконечно.


---

**Итог.** В каждом блоке и на краях (\(P,S\)) число шагов конечно. Блоков конечно. Следовательно, бесконечных цепочек переписываний нет — система **завершаема**.


## 2. Конечность классов эквивалентности по НФ

Нормальная форма - это слово, в котором больше нет вхождений левых частей правил: caa, acb, ad, bd.

Рассмотрим семейство слов c^n, n >= 1.

В них нет ни caa (за c не стоят два a подряд), ни acb (нет a), ни ad (нет d), ни bd (нет b). Значит каждое c^n - нормальная форма. Семейство бесконечно.

Множество нормальных форм бесконечно.


## 3. Локальная конфлюэнтность 

Будем работать под shortlex(сначала длина, потом лексикографически) по алфавиту
```text
a < b < d < c.
```

```text
caa -> ac
acb -> adb  
daaa -> ad 
bc  -> bd
```
В таком виде каждое применение строго уменьшает слово в shortlex, значит полученная ориентированная система убывает по shortlex.

Рассмотрим слово caacb, в котором перекрываются редексы правил (1) и (2).

Левая ветвь (сначала (1)):

```text
caacb -> accb
```

В слове accb нет caa, acb, daaa, bc - это НФ.

Правая ветвь (сначала (2)):

```text
caacb -> caadb
```

Еще шаг по (1):
```text
caadb -> acdb
```
acdb тоже нормальная форма.

Критическая пара не замыкается.
Значит система не локально конфлюэнтна(и соответсвенно не конфлюэнтна).


## 4. Пополняемость по Кнуту–Бендиксу

### 4.1. Первые критические пары и необходимые добавки

**(A) Перекрытие (1) и (2) на слове `caacb`**  
Левое правило - по префиксу `caa`, правое - по суффиксу `acb` (перекрытие по одной букве `a`):

caacb --(1)--> accb

caacb --(2)--> caadb --(1)--> acdb

Нормальные формы различны: `accb` != `acdb`.  
Сравнение по shortlex: длины равны (=4), на 3-й позиции `c>d`, значит `accb > acdb`.

Добавляем:

(5) accb -> acdb

**(B) Перекрытие (3) и (2) на слове `daaacb`**  
Правило (3) по префиксу `daaa`, правило (2) по суффиксу `acb`:

daaacb --(3)--> adcb

daaacb --(2) --> daaadb --(3')--> addb

Нормальные формы различны: `adcb` != `addb`.  
Shortlex: длины равны (=4), на 3-й позиции `c>d`, значит `adcb > addb`.  

Добавляем:

(6) adcb -> addb

**(C) Перекрытие (4) и (1) на слове `bcaa`**  
Правило (4) по префиксу `bc`, правило (1) по суффиксу `caa`:

bcaa --(4)--> bdaa

bcaa --(1) --> bac

Нормальные формы различны: `bdaa` != `bac`.  
Shortlex: длины 4>3, значит `bdaa > bac`.  

Добавляем:

(7) bdaa -> bac

После этих трех добавок имеем расширенную систему:
```text
caa -> ac
acb -> adb  
daaa -> ad
bc  -> bd
accb -> acdb
adcb -> addb
bdaa -> bac
```

### 4.3. Новые перекрытия после (5)–(7) и еще одна добавка

Добавленные правила сами могут образовать критические перекрытия с исходными. Продолжим процесс.

**(D) Перекрытие (1) и (5) на слове `caaccb`**  
`caa` из (1) перекрывается с `accb` из (5):

caaccb --(1)--> accb --(5)--> acdb

caaccb --(5)--> cacdb (НФ)

Разные НФ: `acdb` != `cacdb`.  
Shortlex: длины 4 и 5, значит `cacdb > acdb`.  

Добавляем:

(8) cacdb -> acdb

После этого шага проверяем новые критические пары с участием правила (8) и других. На этом этапе обнаруживается общая закономерность.

### 4.4. Параметрическая бесконечная семья критических пар

Дальнейший перебор перекрытий с участием (5)–(8) проявляет общий 
шаблон локальных пиков, которые замыкаются только добавкой правил 
вида

X cdcb -> X cddb,


где `X` - любой (в том числе пустой) префикс из букв `c` и `d` (иногда с вкраплениями далекой `a` слева, но без непосредственного участия этой a в переписывании фрагмента `cdcb`).

Причина появления шаблона `cdcb -> cddb` такова. Блок символов `dcb` можно преобразовать с помощью правила (6) только если слева от него присутствует буква a:

например, a dcb -> addb (правило (6)).

Однако без ведущей `a` слева (когда слева от `dcb` стоит `c` или `d`) прямого переписывания невозможно: ни одно из `(1),(2),(3),(4),(5),(6),(7),(8)` не переписывает `dcb` или `cdcb` без подпитки буквой `a` слева.

Правила, способные создавать или подводить `a` слева к блоку `dcb`, - это (1) и (3), но:
- (1) требует шаблон `caa` (двойная `a` после `c`);
- (3) требует шаблон `daaa`.

В словах же вида `... cdcb` таких конфигураций рядом с `dcb` нет.  
Таким образом, для слов, содержащих фрагмент `X cdcb` (где `X` - цепочка из `c` и `d` произвольной длины, возможно с редкими `a` далеко слева) развиваются две разные ветви переписывания:

- ветвь, где удается протянуть `a` слева до данного фрагмента, чтобы сработало правило (6): `… adcb -> … addb`;
- ветвь, где этого сделать нельзя, и блок `cdcb` остается неразложимым существующими правилами (ни одно из правил не переписывает `cdcb` без ведущей `a`), и слово с таким фрагментом остается в форме `... cdcb`.

Эти две ветви приводят к разным нормальным формам, то есть возникает критический пик, требующий замыкания. Алгоритм Кнута–Бендикса, чтобы замкнуть конкретный такой пик на слове `X cdcb`, будет добавлять конкретное правило `X cdcb -> X cddb`. Но поскольку `X` может быть сколь угодно длинным (состоящим из любых сочетаний `c` и `d`), получается бесконечно много таких ситуаций. Формально получается бесконечное семейство необходимых добавок:

для любого k >= 0: d^k cdcb -> d^k cddb

для всех m,n >= 0:       c^m d^n cdcb -> c^m d^n cddb

и вообще: для всех X ∈ {c,d}*:  X cdcb -> X cddb

(и то же с дополнительными `c`-вставками слева - это видно по характерным строкам вида `...cdcb -> ...cddb`).

Эта семья правил действительно бесконечна и ее нельзя заменить конечным поднабором за счет уже добавленных правил, потому что ни одно из уже имеющихся правил не умеет убирать ведущие `d`-префиксы: правило (3) `daaa -> ad` срабатывает только при наличии `aaa` после `d`, чего в шаблоне `d^k cdcb` нет. Значит, каждое новое `k` дает новый, не покрываемый контекстом случай - требуется новая левая часть длины `k+4`. Таким образом, алгоритм Кнута-Бендикса будет порождать правила `X cdcb -> X cddb` для всех возможных `X` бесконечно, без остановки.

---

### 4.5. Итог по пополняемости

Порядок shortlex фундирован, но из-за параметрической бесконечной семьи критических пар `X cdcb -> X cddb` требуется бесконечно много добавочных правил.  
Значит, алгоритм Кнута–Бендикса не завершается конечным набором правил. Данная система переписываний **не пополяема**.


## 5. Инварианты

1. Число букв `b` сохраняется.

2. Сумма букв из множества `{c,d}` не меняется.

3. «Скелет без `a`» сохраняется.  
   Определим проекцию `π`, которая удаляет все `a`, буквы `c` и `d` заменяет на один символ `x`, а `b` оставляет как есть. Тогда для каждой пары левой/правой части правил (1)–(4) выполняется `π(lhs) = π(rhs)`.  
   Примеры: `π(caa)=x = π(ac)`, `π(acb)=xb = π(adb)`, `π(ad)=x = π(daaa)`, `π(bd)=bx = π(bc)`.  
   Как следствие:
   - длина скелета `|π(w)|` (число символов `b` и `x`) - инвариант;
   - не меняется последовательность блоков `x` между `b`.

4. Остаточные профили по модулю m. 

    Пусть k(w) = (k0, k1, …, kp) - длины блоков из {c,d} между соседними `b` (где k0 - до первого `b`, а kp - после последнего `b`).

    Остаточный профиль по модулю M ≥ 2.

    r_M(w) = (k0 % M, k1 % M, …, kp % M).