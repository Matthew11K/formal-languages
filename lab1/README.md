# Лабораторная работа №1

## Исходная система переписываний

```text
caa -> ac  (1)
acb -> adb  (2)
ad  -> daaa  (3)
bd  -> bc  (4)
```

## 1. Завершимость

**Скелет по `b`.** Удалим все `a`, а `c,d` сведем к одному символу `x`, получим скелет `π(w)` из букв `{b,x}`. Для всех правил выполняется `π(lhs)=π(rhs)`, значит количество и порядок блоков между соседними `b` не меняется. Дальше разбираем каждый блок независимо.

В каждом блоке (между двумя соседними `b`) посмотрим на его последний символ из `{c,d}` и обозначим через `t` число букв `a` между ним и следующим `b`.
Только этот хвост `t` может меняться правилами (внутренние `c,d` не соприкасаются с `a` справа).

Достаточно показать, что в каждом блоке количество шагов конечно.

---

### Случай A: последний символ `c`.

1) Если `t` нечетно, то правило `caa->ac` применимо ровно `⌊t/2⌋` раз и каждый раз уменьшает `t` на 1. Итог - конфигурация вида `…cab`, где ни одно правило неприменимо в пределах блока.

2) Если `t=2n` четно, применим `caa->ac` ровно `n` раз: получим `…acb`. Далее обязательно и единожды срабатывает цепочка
`acb->adb` (создает `d`), затем `ad->daaa` (дает три `a`), затем (так как слева стоит `b`) `bd->bc`. В результате хвост становится ровно `t:=3`, а последний символ снова `c`, т.е. `…bcaaab`. Теперь одно применение `caa->ac` переводит `t=3` в `t=1` и блок окончательно замораживается как `…bacab`. Повторно `acb` в этом блоке больше не возникнет.

Итак, для `c`-блока выполняется: при нечетном `t` - `⌊t/2⌋` шагов; при четном `t=2n` - `n + 3` шага (ровно одна тройка `acb/ad/daaa/bd` плюс один шаг `caa->ac` после нее).

### Случай B: последний символ `d`.

Здесь возможен только один тип шага внутри блока - `ad->daaa`, и он устраняет конкретную пару `ad` навсегда (обратно `ad` появится только если в этом блоке когда-нибудь снова возникнет `acb`, чего в каждом блоке происходит не более одного раза и только если последний символ был `c`). Следовательно, в `d`-блоке число возможных применений `ad->daaa` конечно.

---

### Итог

- Блоков конечно (это фиксируется скелетом `π(w)`).
- В каждом блоке число шагов конечно.
- Вне блоков (в префиксе до первого `b` и суффиксе после последнего `b`) правила `acb` и `bd` не работают, а `caa->ac` и `ad->daaa` устраняют соответствующие шаблоны за конечное число шагов.

Следовательно, **никакой бесконечной цепочки переписываний не существует**: система переписывания **завершаема**.




## 2. Конечность классов эквивалентности по НФ

Нормальная форма - это слово, в котором больше нет вхождений левых частей правил: caa, acb, ad, bd.

Рассмотрим семейство слов c^n, n >= 1.

В них нет ни caa (за c не стоят два a подряд), ни acb (нет a), ни ad (нет d), ни bd (нет b). Значит каждое c^n - нормальная форма. Семейство бесконечно.

Множество нормальных форм бесконечно.


## 3. Локальная конфлюэнтность 

Будем работать под shortlex(сначала длина, потом лексикографически) по алфавиту
```text
a < b < d < c.
```

```text
caa -> ac
acb -> adb  
daaa -> ad 
bc  -> bd
```
В таком виде каждое применение строго уменьшает слово в shortlex, значит полученная ориентированная система убывает по shortlex.

Рассмотрим слово caacb, в котором перекрываются редексы правил (1) и (2).

Левая ветвь (сначала (1)):

```text
caacb -> accb
```

В слове accb нет caa, acb, daaa, bc - это НФ.

Правая ветвь (сначала (2)):

```text
caacb -> caadb
```

Еще шаг по (1):
```text
caadb -> acdb
```
acdb тоже нормальная форма.

Критическая пара не замыкается.
Значит система не локально конфлюэнтна(и соответсвенно не конфлюэнтна).


## 4. Пополняемость по Кнуту–Бендиксу

### 4.1. Первые критические пары и необходимые добавки

**(A) Перекрытие (1) и (2) на слове `caacb`**  
Левое правило - по префиксу `caa`, правое - по суффиксу `acb` (перекрытие по одной букве `a`):

caacb --(1)--> accb

caacb --(2)--> caadb --(1)--> acdb

Нормальные формы различны: `accb` != `acdb`.  
Сравнение по shortlex: длины равны (=4), на 3-й позиции `c>d`, значит `accb > acdb`.

Добавляем:

(5) accb -> acdb

**(B) Перекрытие (3) и (2) на слове `daaacb`**  
Правило (3) по префиксу `daaa`, правило (2) по суффиксу `acb`:

daaacb --(3)--> adcb

daaacb --(2) --> daaadb --(3')--> addb

Нормальные формы различны: `adcb` != `addb`.  
Shortlex: длины равны (=4), на 3-й позиции `c>d`, значит `adcb > addb`.  

Добавляем:

(6) adcb -> addb

**(C) Перекрытие (4) и (1) на слове `bcaa`**  
Правило (4) по префиксу `bc`, правило (1) по суффиксу `caa`:

bcaa --(4)--> bdaa

bcaa --(1) --> bac

Нормальные формы различны: `bdaa` != `bac`.  
Shortlex: длины 4>3, значит `bdaa > bac`.  

Добавляем:

(7) bdaa -> bac

После этих трех добавок имеем расширенную систему:
```text
caa -> ac
acb -> adb  
daaa -> ad
bc  -> bd
accb -> acdb
adcb -> addb
bdaa -> bac
```

### 4.3. Новые перекрытия после (5)–(7) и еще одна добавка

Добавленные правила сами могут образовать критические перекрытия с исходными. Продолжим процесс.

**(D) Перекрытие (1) и (5) на слове `caaccb`**  
`caa` из (1) перекрывается с `accb` из (5):

caaccb --(1)--> accb --(5)--> acdb

caaccb --(5)--> cacdb (НФ)

Разные НФ: `acdb` != `cacdb`.  
Shortlex: длины 4 и 5, значит `cacdb > acdb`.  

Добавляем:

(8) cacdb -> acdb

После этого шага проверяем новые критические пары с участием правила (8) и других. На этом этапе обнаруживается общая закономерность.

### 4.4. Параметрическая бесконечная семья критических пар

Дальнейший перебор перекрытий с участием (5)–(8) проявляет общий 
шаблон локальных пиков, которые замыкаются только добавкой правил 
вида

X cdcb -> X cddb,


где `X` - любой (в том числе пустой) префикс из букв `c` и `d` (иногда с вкраплениями далекой `a` слева, но без непосредственного участия этой a в переписывании фрагмента `cdcb`).

Причина появления шаблона `cdcb -> cddb` такова. Блок символов `dcb` можно преобразовать с помощью правила (6) только если слева от него присутствует буква a:

например, a dcb -> addb (правило (6)).

Однако без ведущей `a` слева (когда слева от `dcb` стоит `c` или `d`) прямого переписывания невозможно: ни одно из `(1),(2),(3),(4),(5),(6),(7),(8)` не переписывает `dcb` или `cdcb` без подпитки буквой `a` слева.

Правила, способные создавать или подводить `a` слева к блоку `dcb`, - это (1) и (3), но:
- (1) требует шаблон `caa` (двойная `a` после `c`);
- (3) требует шаблон `daaa`.

В словах же вида `... cdcb` таких конфигураций рядом с `dcb` нет.  
Таким образом, для слов, содержащих фрагмент `X cdcb` (где `X` - цепочка из `c` и `d` произвольной длины, возможно с редкими `a` далеко слева) развиваются две разные ветви переписывания:

- ветвь, где удается протянуть `a` слева до данного фрагмента, чтобы сработало правило (6): `… adcb -> … addb`;
- ветвь, где этого сделать нельзя, и блок `cdcb` остается неразложимым существующими правилами (ни одно из правил не переписывает `cdcb` без ведущей `a`), и слово с таким фрагментом остается в форме `... cdcb`.

Эти две ветви приводят к разным нормальным формам, то есть возникает критический пик, требующий замыкания. Алгоритм Кнута–Бендикса, чтобы замкнуть конкретный такой пик на слове `X cdcb`, будет добавлять конкретное правило `X cdcb -> X cddb`. Но поскольку `X` может быть сколь угодно длинным (состоящим из любых сочетаний `c` и `d`), получается бесконечно много таких ситуаций. Формально получается бесконечное семейство необходимых добавок:

для любого k >= 0: d^k cdcb -> d^k cddb

для всех m,n >= 0:       c^m d^n cdcb -> c^m d^n cddb

и вообще: для всех X ∈ {c,d}*:  X cdcb -> X cddb

(и то же с дополнительными `c`-вставками слева - это видно по характерным строкам вида `...cdcb -> ...cddb`).

Эта семья правил действительно бесконечна и ее нельзя заменить конечным поднабором за счет уже добавленных правил, потому что ни одно из уже имеющихся правил не умеет убирать ведущие `d`-префиксы: правило (3) `daaa -> ad` срабатывает только при наличии `aaa` после `d`, чего в шаблоне `d^k cdcb` нет. Значит, каждое новое `k` дает новый, не покрываемый контекстом случай - требуется новая левая часть длины `k+4`. Таким образом, алгоритм Кнута-Бендикса будет порождать правила `X cdcb -> X cddb` для всех возможных `X` бесконечно, без остановки.

---

### 4.5. Итог по пополняемости

Порядок shortlex фундирован, но из-за параметрической бесконечной семьи критических пар `X cdcb -> X cddb` требуется бесконечно много добавочных правил.  
Значит, алгоритм Кнута–Бендикса не завершается конечным набором правил. Данная система переписываний **не пополяема**.


## 5. Инварианты

1. Число букв `b` сохраняется.

2. Сумма букв из множества `{c,d}` не меняется.

3. «Скелет без `a`» сохраняется.  
   Определим проекцию `π`, которая удаляет все `a`, буквы `c` и `d` заменяет на один символ `x`, а `b` оставляет как есть. Тогда для каждой пары левой/правой части правил (1)–(4) выполняется `π(lhs) = π(rhs)`.  
   Примеры: `π(caa)=x = π(ac)`, `π(acb)=xb = π(adb)`, `π(ad)=x = π(daaa)`, `π(bd)=bx = π(bc)`.  
   Как следствие:
   - длина скелета `|π(w)|` (число символов `b` и `x`) - инвариант;
   - не меняется последовательность блоков `x` между `b`.

4. Остаточные профили по модулю m. 

    Пусть k(w) = (k0, k1, …, kp) - длины блоков из {c,d} между соседними `b` (где k0 - до первого `b`, а kp - после последнего `b`).

    Остаточный профиль по модулю M ≥ 2.

    r_M(w) = (k0 % M, k1 % M, …, kp % M).