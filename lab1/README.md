# Лабораторная работа №1

## Исходная система переписываний

```text
caa -> ac  (1)
acb -> adb  (2)
ad  -> daaa  (3)
bd  -> bc  (4)
```

## 1. Завершимость




## 2. Конечность классов эквивалентности по НФ

Нормальная форма - это слова, в котором больше нет вхождений левых частей правил: caa, acb, ad, bd.

Рассмотрим семейство слов C^n, n >= 1.

В них нет ни caa (за c не стоят два a подряд), ни acb (нет a), ни ad (нет d), ни bd (нет b). Значит каждое C^n - НФ. Семейство бесконечно.

Множество нормальных форм бесконечно.


## 3. Локальная конфлюэнтность 

Будем работать под shortlex(сначала длина, потом лексикографически) по алфавиту
```text
a < b < d < c.
```

```text
caa -> ac
acb -> adb  
daaa -> ad 
bc  -> bd
```
В таком виде каждое применение строго уменьшает слово в shortlex, значит система терминируема.

Рассмотрим слово caacb, в котором перекрываются редексы правил (1) и (2).

Левая ветвь (сначала (1)):

```text
caacb -> accb
```

В слове accb нет caa, acb, daaa, bc — это НФ.

Правая ветвь (сначала (2)):

```text
caacb -> caadb
```

Еще шаг по (1):
```text
caadb -> acdb
```
acdb тоже нормальная форма.

Критическая пара не замыкается.
Значит система не локально конфлюэнтна(и соответсвенно не конфлюэнтна).


## 4. Пополняемость по Кнуту–Бендиксу

### 4.1. Первые критические пары и необходимые добавки

**(A) Перекрытие (1) и (2) на слове `caacb`**  
Левое правило — по префиксу `caa`, правое — по суффиксу `acb` (перекрытие по одной букве `a`):

caacb --(1)--> accb

caacb --(2)--> caadb --(1)--> acdb

Нормальные формы различны: `accb` != `acdb`.  
Сравнение по shortlex: длины равны (=4), на 3-й позиции `c>d`, значит `accb > acdb`.

Добавляем:

(5) accb -> acdb

**(B) Перекрытие (3) и (2) на слове `daaacb`**  
Правило (3) по префиксу `daaa`, правило (2) по суффиксу `acb`:

daaacb --(3)--> adcb

daaacb --(2) --> daaadb --(3')--> addb

Нормальные формы различны: `adcb` != `addb`.  
Shortlex: длины равны (=4), на 3-й позиции `c>d`, значит `adcb > addb`.  

Добавляем:

(6) adcb -> addb

**(C) Перекрытие (4) и (1) на слове `bcaa`**  
Правило (4) по префиксу `bc`, правило (1) по суффиксу `caa`:

bcaa --(4)--> bdaa

bcaa --(1) --> bac

Нормальные формы различны: `bdaa` != `bac`.  
Shortlex: длины 4>3, значит `bdaa > bac`.  

Добавляем:

(7) bdaa -> bac

После этих трёх добавок имеем расширенную систему:
```text
caa -> ac
acb -> adb  
daaa -> ad
bc  -> bd
accb -> acdb
adcb -> addb
bdaa -> bac
```

### 4.3. Новые перекрытия после (5)–(7) и ещё одна добавка

Добавленные правила сами могут образовать критические перекрытия с исходными. Продолжим процесс.

**(D) Перекрытие (1) и (5) на слове `caaccb`**  
`caa` из (1) перекрывается с `accb` из (5):

caaccb --(1)--> accb --(5)--> acdb

caaccb --(5)--> cacdb (НФ)

Разные НФ: `acdb` != `cacdb`.  
Shortlex: длины 4 и 5, значит `cacdb > acdb`.  

Добавляем:

(8) cacdb -> acdb

После этого шага проверяем новые критические пары с участием правила (8) и других. На этом этапе обнаруживается общая закономерность.

### 4.4. Параметрическая бесконечная семья критических пар

Дальнейший перебор перекрытий с участием (5)–(8) проявляет общий 
шаблон локальных пиков, которые замыкаются только добавкой правил 
вида

X cdcb -> X cddb,


где `X` — любой (в том числе пустой) префикс из букв `c` и `d` (иногда с вкраплениями далёкой `a` слева, но без непосредственного участия этой a в переписывании фрагмента `cdcb`).

Причина появления шаблона `cdcb -> cddb` такова. Блок символов `dcb` можно преобразовать с помощью правила (6) только если слева от него присутствует буква a:

например, a dcb -> addb (правило (6)).

Однако без ведущей `a` слева (когда слева от `dcb` стоит `c` или `d`) прямого переписывания невозможно: ни одно из `(1),(2),(3),(4),(5),(6),(7),(8)` не переписывает `dcb` или `cdcb` без «подпитки» буквой `a` слева.

Правила, способные создавать или подводить `a` слева к блоку `dcb`, - это (1) и (3), но:
- (1) требует шаблон `caa` (двойная `a` после `c`);
- (3) требует шаблон `daaa`.

В словах же вида `... cdcb` таких конфигураций рядом с `dcb` нет.  
Таким образом, для слов, содержащих фрагмент `X cdcb` (где `X` - цепочка из `c` и `d` произвольной длины, возможно с редкими `a` далеко слева) развиваются две разные ветви переписывания:

- ветвь, где удаётся протянуть `a` слева до данного фрагмента, чтобы сработало правило (6): `… adcb -> … addb`;
- ветвь, где этого сделать нельзя, и блок `cdcb` остаётся неразложимым существующими правилами (ни одно из правил не переписывает `cdcb` без ведущей `a`), и слово с таким фрагментом остаётся в форме `... cdcb`.

Эти две ветви приводят к разным нормальным формам, то есть возникает критический пик, требующий замыкания. Алгоритм Кнута–Бендикса, чтобы замкнуть конкретный такой пик на слове `X cdcb`, будет добавлять конкретное правило `X cdcb -> X cddb`. Но поскольку `X` может быть сколь угодно длинным (состоящим из любых сочетаний `c` и `d`), получается бесконечно много таких ситуаций. Формально получается бесконечное семейство необходимых добавок:

для любого k >= 0: d^k cdcb -> d^k cddb

для всех m,n >= 0:       c^m d^n cdcb -> c^m d^n cddb

и вообще: для всех X ∈ {c,d}*:  X cdcb -> X cddb

(и то же с дополнительными `c`-вставками слева — это видно по характерным строкам вида `...cdcb -> ...cddb`).

Эта семья правил действительно бесконечна и ее нельзя заменить конечным поднабором за счет уже добавленных правил, потому что ни одно из уже имеющихся правил не умеет убирать ведущие `d`-префиксы: правило (3) `daaa -> ad` срабатывает только при наличии `aaa` после `d`, чего в шаблоне `d^k cdcb` нет. Значит, каждое новое `k` даёт новый, не покрываемый контекстом случай — требуется новая левая часть длины `k+4`. Таким образом, алгоритм Кнута-Бендикса будет порождать правила `X cdcb -> X cddb` для всех возможных `X` бесконечно, без остановки.

---

### 4.5. Итог по пополняемости

Порядок shortlex фундирован, но из-за параметрической бесконечной семьи критических пар `X cdcb -> X cddb` требуется бесконечно много добавочных правил.  
Значит, алгоритм Кнута–Бендикса не завершается конечным набором правил. Данная система переписываний **не пополяема**.